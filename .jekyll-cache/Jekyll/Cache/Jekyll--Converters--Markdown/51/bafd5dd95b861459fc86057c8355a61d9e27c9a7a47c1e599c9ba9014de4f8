I"8<h2 id="server-client-architecture">Server Client Architecture</h2>
<p>서버</p>
<ul>
  <li>always-on host</li>
  <li>IP 주소 고정</li>
  <li>데이터 센터 존재</li>
</ul>

<p>클라이언트</p>
<ul>
  <li>필요시에만 연결</li>
  <li>동적 IP 주소 가질 수 있음</li>
  <li>클라이언트끼리 통신하지 않음</li>
</ul>

<p>Client-Server Computing의 장점</p>
<ul>
  <li>데이터를 서버에서만 제공하기 때문에 서버만 유저의 authorization과 데이터 protection을 관리하면 된다</li>
  <li>기능의 분리(서버는 데이터를 주기만 하고 클라이언트는 데이터를 받기만 한다)로 모든 노드가 독립적이고 확장과 유지 보수가 쉽다</li>
</ul>

<p>Client-Server Computing의 단점</p>
<ul>
  <li>traffic이 몰릴 수 있다(반면 P2P는 self scability)</li>
</ul>

<h2 id="p2p">P2P</h2>
<ul>
  <li>네트워크에 있는 모든 사용자가 자원을 요청할 수도, 제공할 수도 있음</li>
  <li>always-on server 없음</li>
  <li>self scalability : peer가 늘어날 때 마다 데이터를 요청하는 node도 늘어나지만 데이터를 제공하는 node도 늘어난다 (service capability 증가)</li>
  <li>peer는 간헐적으로 연결되어 있고 IP가 바뀌기 때문에 관리가 어려움</li>
</ul>

<h2 id="process-communicating">Process communicating</h2>
<p>프로세스 : 호스트가 실행중인 프로그램
같은 호스트 내 두 프로세스는 inter-process communication로 정보를 주고 받는다
다른 호스트의 두 프로세스는 message를 통해 정보를 주고 받는다</p>

<p>client process : communication 시작하는 프로세스
server process : communication을 기다리는 프로세스</p>

<p>P2P는 각 peer가 client process, server process 가진다</p>

<p>프로세스는 socket을 통해 메세지를 주고 받는다</p>

<p>IP Address : 네트워크 상에서 호스트를 식별가능 하게 함
port : 호스트내의 여러 프로세스를 식별가능하게 한다
통신은 프로세스끼리 하기 때문에 port번호가 반드시 필요하다</p>

<h2 id="application의-종류에-따라-요구되는-특성">application의 종류에 따라 요구되는 특성</h2>
<ul>
  <li>data integrity : 파일 전송은 100 퍼센트 integrity 보장해야 하고 오디오는 조금 달라져도 괜찮다</li>
  <li>timing(latency) : 게임, 전화는 delay가 있으면 안되고 파일 전송은 조금 늦어져도 큰 상관은 없다</li>
  <li>throughput : 스트리밍은 버퍼가 없어야 한다</li>
  <li>security</li>
</ul>

<p>latency : data transfer &lt;-&gt; received 사이의 왕복 또는 편도 시간
throughput : 단위시간 당 전송되는 데이터의 양</p>

<h2 id="internet-transport-protocols---tcp-udp">Internet transport protocols - TCP, UDP</h2>
<p>TCP</p>
<ul>
  <li>데이터 보내기전에 연결을 위한 setup 필요하다</li>
  <li>flow control : receiver에 버퍼 쌓이면 sender가 보내는 패킷의 양 조절</li>
  <li>congestion control : 네트워크에 buffer 쌓이면 sender가 보내는 패킷의 양 조절</li>
  <li>data integrity 보장</li>
</ul>

<p>UDP</p>
<ul>
  <li>노드끼리 연결 없이 데이터 전송 : overhead 줄어듬</li>
  <li>data integrity 보장 안 함, application에서 data integrity 보장하면 굳이 transport 계층에서 data integrity 보장할 필요는 없다</li>
  <li>flow control 없기 때문에 최소 frame 보장</li>
</ul>

<p>두 프로토콜 모두 보안은 application layer에서 수행</p>

<h2 id="웹과-http">웹과 HTTP</h2>
<p>웹페이지 구성 : base HTML + objects(image, audio 등등..)
각 object는 URL 주소로 나타낸다. (ex. https://www.itfind.or.kr/WZIN/jugidong/1888/file6111801471006205940-188802.pdf)</p>

<p>HTTP(hypertext transfer protocol) : hypertext link를 통해 웹 페이지를 주고 받는 프로토콜
특징</p>
<ul>
  <li>클라이언트의 TCP 연결요청으로 시작 (참고 : HTTP/3은 UDP를 쓴다)</li>
  <li>서버가 TCP를 수락하면서 통신</li>
  <li>브라우저와 웹 서버 간의 HTTP 메시지가 교환된다</li>
  <li>stateless : 서버는 클라이언트가 이전에 요청했던 정보를 유지하지 않는다, 즉 같은 클라이언트의 요청이더라도 각 통신은 독립적이다</li>
  <li>persistent HTTP(keep-alive) :
client가 각 base url 뿐만 아니라 각 object또한 http 요청으로 받아와야 한다.
한 페이지에 다수의 object가 있을 경우 각 object마다 새로 연결을 맺지 않고 기존에 맺었던 연결로 object를 가져온다.</li>
</ul>

<h2 id="http-request-message">HTTP request message</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) status line
GET /index.html HTTP/1.1\r\n
2) header lines
Host: www-net.cs.umass.edu\r\n
User-Agent: Firefox/3.6.10\r\n
Accept: text/html,application/xhtml+xml\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip,deflate\r\n
Accept-Charset: ISO-8859-1,utf-8;q=0.7\r\n
Keep-Alive: 115\r\n
Connection: keep-alive\r\n
\r\n
</code></pre></div></div>
<p><strong>1) status line : method 종류 + url + http version</strong></p>
<ul>
  <li>method는 데이터를 전송하는 방식을 규정한다
    <ul>
      <li>GET — For returning resources</li>
      <li>POST — For creating a new resource</li>
      <li>PUT — For updating a resource</li>
      <li>PATCH — For updating a resource</li>
      <li>DELETE — For deleting a resource</li>
    </ul>

    <p>method는 주로 GET과 POST가 쓰인다<br />
GET은 서버로 파라미터를 전달할 때 url에 값이 담긴다 <br />
네이버에 http method라고 검색하면 주소창에 <code class="language-plaintext highlighter-rouge">query=http+method</code>가 노출된다.<br />
<a href="https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=http+method">search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=http+method</a><br />
POST는 서버로 파라미터를 전달할 때 request body에 담긴다. 따라서 url 주소로 노출되지 않는다.</p>

    <p>개발할 때 굳이 위의 규칙을 지키지 않아도 잘 작동하기는 한다.</p>
    <ul>
      <li>왜 http method를 따라야 할까?</li>
      <li><a href="https://medium.com/@suhas_chatekar/why-you-should-use-the-recommended-http-methods-in-your-rest-apis-981359828bf7">medium.com/@suhas_chatekar/why-you-should-use-the-recommended-http-methods-in-your-rest-apis-981359828bf7</a><br />
idempotent operation란 operation에 의해 상태가 변하지 않음을 의미한다.<br />
서버에서 이는 서버의 상태를 변화시키지 않는다는 것을 의미한다.<br />
GET, PUT, DELETE로는 서버의 자원이 변하지 않고(않을 수 있고) POST, PATCH는 서버의 자원이 변한다. 자세한 건 지금은 넘어가자</li>
    </ul>

    <p>클라이언트 입장에서 GET으로 같은 요청을 여러번 보내도(새로고침을 여러번해도) 서버의 자원을 받아오기만 하는 것이기 때문에 상관없다(ex. 네이버 검색결과)<br />
클라이언트는 GET요청을 여러번 요청해도 서버에 영향이 없을 것이라고 생각한다.<br />
하지만 주문 요청을 하는 POST요청을 여러번 보내는 것은 문제가 있을 수 있다.<br />
POST요청 결과를 새로고침하면 다음과 같은 창이 나타난다.
<img src="/assets/img/postRefresh.jpg" alt="postRefresh" /><br />
또한, 동일한 GET요청을 보냈을 시 이전에 보냈던 요청과 같은 결과를 받을 것으로 기대할 수 있기 때문에 caching이 가능하다</p>

    <p><img src="/assets/img/cookie.png" alt="cookie" /></p>

    <p>아래는 내 생각이다. get으로 커피주문 시나리오를 보자<br />
<img src="/assets/img/coffeeOrder.jpg" alt="coffeeOrder" /><br />
GET으로 POST에서 할법한 요청을 처리했을 때 캐싱하면 안 될 요청을 캐싱할 수 있으므로 조심하자</p>
  </li>
  <li>url 는 네트워크에서 자원이 어디있는 지 알려준다</li>
  <li>http version : http 프로토콜 버전 정보
<a href="https://www.rfc-editor.org/rfc/rfc2145#section-2.3">www.rfc-editor.org/rfc/rfc2145#section-2.3</a><br />
자세히는 모르겠지만 이걸 보면 엄격하게 버전에 맞춰서 서버가 응답을 안해줘도 되는 것 같다</li>
</ul>

<p><strong>2) header lines : 부가적인 정보</strong>
서버가 어떻게 response 해야할 지 알려준다</p>

<h2 id="http-request-message-1">HTTP request message</h2>
<p>강의에서 자세히 다루지 않아서 따로 적겠습니다</p>

<h2 id="쿠키">쿠키</h2>
<p>HTTP 요청은 stateless, 즉 서버는 요청을 보낸 클라이언트가 이전 요청에서 로그인을 했는 지 안 했는 지 알 수 없다.<br />
따라서, 서버에 요청 시 쿠키를 보내서 이전 요청에서 로그인 했다는 사실을 서버에게 알려준다.</p>

<h1 id="웹-캐시">웹 캐시</h1>
<p>웹 캐시 종류 : 브라우저 캐시, 프록시 웹 캐시<br />
클라이언트가 서버로 요청을 보낼 때 프록시 서버를 경유하게 한다.</p>

<p>프록시 서버</p>
<ul>
  <li>클라이언트가 서버 대신 프록시 서버에 요청한다.</li>
  <li>프록시 서버는 응답을 서버로부터 가져오고 해당 응답을 프록시 서버에 저장한다.</li>
  <li>동일한 요청이 오면 서버를 거치지 않고 프록시서버에서 응답을 해준다</li>
</ul>

<p>Conditional Get</p>
<ul>
  <li>너무 오래된 응답페이지를 클라이언트에게 보내면 안된다.</li>
  <li>신선도 검사 후 페이지의 최근 수정일을 서버에게 보낸다.</li>
  <li>서버가 수정되었다면 프록시 서버에게 새로운 페이지를 보낸다.</li>
  <li>헤더만 주고 받기 때문에 비용이 적다</li>
</ul>

<h2 id="이메일">이메일</h2>
<p>이메일이 보내지는 과정<br />
Computer(user agent) — mail server — internet — mail server — Computer(user agent)</p>

<p>User Agent</p>
<ul>
  <li>서버에 있는 메일을 불러오거나 메일을 쓸 수 있다</li>
  <li>ex. OutLook, iPhone mail client</li>
</ul>

<p>Mail server</p>
<ul>
  <li>도메인 (@naver.com, @gmail.com) 별로 존재</li>
  <li>mailbox : 저장된 이메일 저장, 사용자 별로 존재한다</li>
  <li>message queue : 보낼 이메일 대기열</li>
</ul>

<p>SMTP</p>
<ul>
  <li>클라이언트에서 메일서버로 통신할 때, 메일서버끼리 통신할 때 쓰임</li>
  <li>TCP, PORT 25에서 통신</li>
</ul>

<p>POP3, IMAP</p>
<ul>
  <li>클라이언트가 메일서버의 메일 가져올 때 쓰임(HTTP도 쓰일 수 있다)</li>
  <li>POP3는 메일을 받으면 해당 서버에서 메시지가 삭제됨</li>
  <li>IMAP는 삭제 안됨</li>
</ul>

<p>회사에서 여전히 이메일을 쓰는 이유</p>
<ul>
  <li>영구저장 : 카카오톡으로 이미지를 주고 받을 때를 생각해보면 유효기간이 있음</li>
  <li>보안 : 뛰어난 보안으로 내가 의도한 사람에게만 메일을 보낼 수 있다</li>
  <li>여러가지 검색해보았지만 위 두가지 이유 외에는 다른 메시지 앱도 해당하는 기능이었음(편리성, 신속성 등등)</li>
</ul>

<h1 id="dns">DNS</h1>
<p>www.naver.com 를 주소창에 검색하면 바로 네이버 서버로 접근 하는것이 아니다<br />
네이버 서버에 접근하기 위해서는 네이버 서버의 IP 주소가 필요하다.<br />
DNS는 도메인을 IP 주소로 변환해준다.</p>

<ul>
  <li>cmd 실행</li>
  <li><code class="language-plaintext highlighter-rouge">nslookup www.naver.com</code> 입력</li>
</ul>

<p>Addresses에 있는 223.130.200.107, 223.130.195.200 로 네이버 서버에 접근한다.<br />
실제로 검색된 IP주소를 복사하여 주소창에 붙여넣어도 네이버 페이지로 접속된다.<br />
IP 주소를 사람이 직접 외우기 어렵기 때문에 DNS 서버를 쓴다.</p>

<p><strong>DNS 종류</strong></p>
<ul>
  <li>도메인은 로컬 DNS가 3가지 종류의 DNS 서버를 순차적으로 접근하여 IP 주소가 검색한다.</li>
  <li>root DNS server : 로컬 DNS가 DNS 서버에 접근할 때 가장 먼저 거치는 곳, .edu .org .kr 등의 TLD DNS 서버의 위치를 알려준다.</li>
  <li>TLD DNS server : 각 기관(naver, daum)의 authoritative DNS server 의 위치를 알려준다.</li>
  <li>authoritative DNS server : 기관이 관리하는 도메인의 주소를 알려준다. 네이버가 관리하는 도메인 예시 : <code class="language-plaintext highlighter-rouge">www.naver.com</code>, <code class="language-plaintext highlighter-rouge">mail.naver.com</code>, <code class="language-plaintext highlighter-rouge">section.blog.naver.com</code></li>
  <li>여러개로 DNS를 쪼개면 단일 DNS 서버가 존재하는 것 보다 트래픽이 낮다.</li>
</ul>

<p><strong>iterated vs recursive</strong></p>
<ul>
  <li>iterated query : 각 DNS는 로컬 DNS에게 DNS 서버의 위치만 알려준다. 예를 들어 <code class="language-plaintext highlighter-rouge">www.naver.com</code>을 검색할 때 root DNS 서버가 .com을 담당하는 TLD DNS server의 위치를 로컬 DNS 서버에게 알려준다. 로컬 DNS 서버는 TLD DNS server에 다시 물어봐야 한다.</li>
  <li>recursive query : 각 DNS server는 하위계층(계층은 root, TLD, authoritative 순)의 DNS 서버에게 도메인 주소를 직접 물어본다. 따라서 로컬 DNS가 root DNS 서버에게 <code class="language-plaintext highlighter-rouge">www.naver.com</code>을 검색하면 해당 IP를 직접 반환해준다.</li>
  <li>recursive query는 상위 DNS에서 load가 크다.</li>
</ul>

<p><strong>DNS records</strong>
RR format: (name, value, type, ttl)</p>
<ul>
  <li>type=A : name=hostname, value=IP address ex) <code class="language-plaintext highlighter-rouge">google.com, XX.XXX.XXX.XXX, A, 1100</code></li>
  <li>type=NS : name=domian, value=authoritative name server</li>
  <li>type=CNAME : name=alias, value = canonical name, 우리가 www.ibm.com 이라고 하는 것은 별칭일 수도 있다. servereast.backup2.ibm.com가 실제이름이고 실제이름이 복잡할 때 쓸 수 있다.</li>
  <li>type=MX : name=domain, value=mail server</li>
  <li>ttl은 캐싱의 신선도를 체크할 때 쓰인다.</li>
</ul>

:ET